 if(once)
    {
    once = false;
    vector<vec3> face = {vec3(-0.5,0.5,-0.5), vec3(-0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(0.5,0.5,-0.5)};

    mesh->vertices = face;
    mesh->indices = {0,1,2,2,3,0};
    mesh->uvs = {vec2(0), vec2(0,1), vec2(1/6.f,1), vec2(1/6.f,0)};

    Shader vertex, fragment;

    createShader(vertex, "./Shaders/FaceVertexShader.glsl", GL_VERTEX_SHADER);
    createShader(fragment, "./Shaders/FragmentShader.glsl", GL_FRAGMENT_SHADER);
    
    p = glCreateProgram();

    glAttachShader(p, vertex.shaderID);
    glAttachShader(p, fragment.shaderID);

    printShaderInfoLog(vertex.shaderID);
    printShaderInfoLog(fragment.shaderID);
    
    glLinkProgram(p);
    glUseProgram(p);

    glGenBuffers(1, &experiment);
    glGenBuffers(1, &experiment2);
    }
    //glUseProgram(p);
    glBindVertexArray(mesh->vertexArray);
    glBindVertexArray(mesh->vertexArray);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->vertexBuffer);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->vertices.size()*sizeof(vec3), 
        mesh->vertices.data(), GL_DYNAMIC_DRAW);

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->normalsBuffer);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_TRUE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->normals.size()*sizeof(vec3),
        mesh->normals.data(), GL_DYNAMIC_DRAW);
    
    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->uvBuffer);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(vec2), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->uvs.size()*sizeof(vec2),
        mesh->uvs.data(), GL_DYNAMIC_DRAW);

    //TODO: figure out if other buffers are faster
    vector<int> face_types = {Top, Bottom, Left, Right, Back, Front};
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, experiment);
    glBufferData(GL_SHADER_STORAGE_BUFFER, face_types.size()*sizeof(Face), face_types.data(), GL_DYNAMIC_COPY);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, experiment);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); // unbind

    vector<vec3> move = {vec3(0), vec3(1), vec3(0,0,1), vec3(1,0,0), vec3(0,1,0), vec3(4)};
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, experiment2);
    glBufferData(GL_SHADER_STORAGE_BUFFER, move.size()*sizeof(vec3), move.data(), GL_DYNAMIC_COPY);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, experiment2);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); // unbind

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->elmentBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh->indices.size()*sizeof(uint),
        mesh->indices.data(), GL_DYNAMIC_DRAW);

    glUseProgram(programs[0]);

    //loadModelMatrix(p, glm::translate(mat4(1), vec3(0)));
    //loadGeometryArrays(p, *mesh);
   /* loadTexture(p, *texture);

    if(!loadViewProjMatrix(cam, p))
    {
        cerr << "Error when loading projection matrix!" << endl;
        return;
    }

    glDrawElementsInstanced(GL_TRIANGLES, mesh->indices.size(), GL_UNSIGNED_INT, (void*)0, face_types.size());*/

    //render(programs[0], *mesh, GL_TRIANGLES);


   /* loadModelMatrix(programs[0], glm::translate(mat4(1), position));
    loadGeometryArrays(programs[0], *mesh);
    loadTexture(programs[0], *texture);

    render(programs[0], *mesh, GL_TRIANGLES);*/





    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/*
*	Author:	Camilo Talero
*
*
*	Version: 0.0.1
*
*	Basic vertex shader
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#version 450

#define PI 3.1415926535897932384626433832795

layout(location = 0) in vec3 position; //(x,y,z) coordinates of a vertex
layout(location = 1) in vec3 norm; //a 3D vertex representing the normal to teh vertex 
layout(location = 2) in vec2 texture_coordinate;

layout(std430, binding = 3) buffer face_buffer
 {
     int face_types[];
 };

layout(std430, binding = 4) buffer face_buffer
{
    vec3 translation[];
};

out vec3 normal; 
out vec3 vertexPos; //projected vertex
out vec2 texture_coord;

uniform mat4 model = mat4(1); //Position and orientation of the current object
uniform mat4 view = mat4(1); //Camera orientation and position
uniform mat4 proj = mat4(1); //the projection parameters (FOV, viewport dimensions)
//uniform int face_types[2048];

//Taken from: https://gist.github.com/neilmendoza/4512992
mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main()
{
    //int face_type = face_types[gl_InstanceID];
    mat4 rotation = mat4(1);
    switch(face_types[gl_InstanceID])
    {
        case 0:
            rotation = mat4(1);
            break;
        case 1:
            rotation = rotationMatrix(vec3(0,0,1), -PI/2.f);
            break;
        case 2:
            rotation = rotationMatrix(vec3(0,0,1), PI/2.f);
            break;
        case 3:
            rotation = rotationMatrix(vec3(0,0,1), PI);
            break;
        case 4:
            rotation = rotationMatrix(vec3(1,0,0), PI/2.f);
            break;
        case 5:
            rotation = rotationMatrix(vec3(1,0,0), -PI/2.f);
            break;
        
        default:
            rotation = mat4(1);
            break;
    }

    gl_Position = proj*view*model*rotation*vec4(position, 1.0);
    normal = vec3(model*vec4(norm,1.0));
    vertexPos = vec3(model*vec4(position, 1.0)); //calculate the transformed pos
    texture_coord = texture_coordinate + vec2(face_types[gl_InstanceID]*(1/6.f),0);
}

if(once)
    {
    once = false;
    vector<vec3> face = {vec3(-0.5,0.5,-0.5), vec3(-0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(0.5,0.5,-0.5)};

	createGeometry(mesh);
    mesh.vertices = face;
    mesh.indices = {0,1,2,2,3,0};
    mesh.uvs = {vec2(0), vec2(0,1), vec2(1/6.f,1), vec2(1/6.f,0)};

    glGenBuffers(1, &experiment);
	glGenBuffers(1, &experiment2);
	
	glBindVertexArray(mesh.vertexArray);
	
	glBindBuffer(GL_ARRAY_BUFFER, mesh.vertexBuffer);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size()*sizeof(vec3), 
		mesh.vertices.data(), GL_DYNAMIC_DRAW);

    glBindBuffer(GL_ARRAY_BUFFER, mesh.normalsBuffer);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_TRUE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh.normals.size()*sizeof(vec3),
        mesh.normals.data(), GL_DYNAMIC_DRAW);
    
    glBindBuffer(GL_ARRAY_BUFFER, mesh.uvBuffer);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(vec2), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh.uvs.size()*sizeof(vec2),
		mesh.uvs.data(), GL_DYNAMIC_DRAW);

	//Set the element buffer (non linear reading/loading of data information)
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.elmentBuffer);
	//Indicate how to read the element data
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size()*sizeof(uint),
		mesh.indices.data(), GL_DYNAMIC_DRAW);
	}

	glBindVertexArray(mesh.vertexArray);
	
	glUseProgram(current_program);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, mesh.vertexBuffer);
	

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, mesh.normalsBuffer);
   
    
    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, mesh.uvBuffer);
   

	//Set the element buffer (non linear reading/loading of data information)
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.elmentBuffer);
	//Indicate how to read the element data
	

	glDrawElements(GL_TRIANGLES, mesh.indices.size(), GL_UNSIGNED_INT, (void*)0);