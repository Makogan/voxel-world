 if(once)
    {
    once = false;
    vector<vec3> face = {vec3(-0.5,0.5,-0.5), vec3(-0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(0.5,0.5,-0.5)};

    mesh->vertices = face;
    mesh->indices = {0,1,2,2,3,0};
    mesh->uvs = {vec2(0), vec2(0,1), vec2(1/6.f,1), vec2(1/6.f,0)};

    Shader vertex, fragment;

    createShader(vertex, "./Shaders/FaceVertexShader.glsl", GL_VERTEX_SHADER);
    createShader(fragment, "./Shaders/FragmentShader.glsl", GL_FRAGMENT_SHADER);
    
    p = glCreateProgram();

    glAttachShader(p, vertex.shaderID);
    glAttachShader(p, fragment.shaderID);

    printShaderInfoLog(vertex.shaderID);
    printShaderInfoLog(fragment.shaderID);
    
    glLinkProgram(p);
    glUseProgram(p);

    glGenBuffers(1, &experiment);
    glGenBuffers(1, &experiment2);
    }
    //glUseProgram(p);
    glBindVertexArray(mesh->vertexArray);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->vertexBuffer);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->vertices.size()*sizeof(vec3), 
        mesh->vertices.data(), GL_DYNAMIC_DRAW);

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->normalsBuffer);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_TRUE, sizeof(vec3), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->normals.size()*sizeof(vec3),
        mesh->normals.data(), GL_DYNAMIC_DRAW);
    
    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, mesh->uvBuffer);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(vec2), (void*)0);
    glBufferData(GL_ARRAY_BUFFER, mesh->uvs.size()*sizeof(vec2),
        mesh->uvs.data(), GL_DYNAMIC_DRAW);

    //TODO: figure out if other buffers are faster
    vector<int> face_types = {Top, Bottom, Left, Right, Back, Front};
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, experiment);
    glBufferData(GL_SHADER_STORAGE_BUFFER, face_types.size()*sizeof(Face), face_types.data(), GL_DYNAMIC_COPY);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, experiment);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); // unbind

    vector<vec3> move = {vec3(0), vec3(1), vec3(0,0,1), vec3(1,0,0), vec3(0,1,0), vec3(4)};
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, experiment2);
    glBufferData(GL_SHADER_STORAGE_BUFFER, move.size()*sizeof(vec3), move.data(), GL_DYNAMIC_COPY);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, experiment2);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); // unbind

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->elmentBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh->indices.size()*sizeof(uint),
        mesh->indices.data(), GL_DYNAMIC_DRAW);

    glUseProgram(programs[0]);

    //loadModelMatrix(p, glm::translate(mat4(1), vec3(0)));
    //loadGeometryArrays(p, *mesh);
   /* loadTexture(p, *texture);

    if(!loadViewProjMatrix(cam, p))
    {
        cerr << "Error when loading projection matrix!" << endl;
        return;
    }

    glBindVertexArray(mesh->vertexArray);
    glDrawElementsInstanced(GL_TRIANGLES, mesh->indices.size(), GL_UNSIGNED_INT, (void*)0, face_types.size());*/

    //render(programs[0], *mesh, GL_TRIANGLES);


   /* loadModelMatrix(programs[0], glm::translate(mat4(1), position));
    loadGeometryArrays(programs[0], *mesh);
    loadTexture(programs[0], *texture);

    render(programs[0], *mesh, GL_TRIANGLES);*/